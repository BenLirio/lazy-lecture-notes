Maybe I can start by just writing on the board what I wanted to show. I wanted to start by recalling what we have seen yesterday. First, we started from a small imperative language called Ip. This language is defined by its semantics. First, we have seen this language is made of expressions and commands. Yesterday, we have seen a function for evaluating expressions. That is a big step semantics. Then, we have seen a relation describing the big step semantics for commands as well. This is a source language. Then, we have seen the target language, a small virtual machine. In this virtual machine, there are only expressions. Then, we have defined the semantics of this language using a small step semantics. Then, we have discussed about the compiler from Ip to VM. Then, I have shown you the theorem about the compiler. Initially, the first theorem I have shown you yesterday was only about expressions. Then, we added commands to the language. Hi. Okay, because it doesn't work. Okay. We wrote our first theorem. Then, we said, okay, let's extend our language with commands. Then, we have here Y loops. Because of Y loops, the theorem we had before was only for terminating programs. But if we have Y loops, the program may diverge. We discussed about what are the possible behaviors of programs. Initially, in the first version of the theorem, there was only one behavior. Or, when we only had expressions, any evaluation of an expression was terminated. So, there was only one behavior, which was termination, right? Then, when we added Y loops, I told you that the program may diverge. So, we had to observe another behavior, that is divergence. Okay, great. Thank you. So, this is where we started yesterday with this big-step semantics. Big-step semantics is a relation like this one. The execution of a command T updates semantic state S into a semantic state S', right? Then, we added loops. So, now we had diverging programs. And now, we have two kinds of behavior that we want to preserve. Termination and divergence. Because program may diverge, we switch from a big-step semantics to a small-step semantics. In theory, it's possible to write big-step semantics for diverging programs, but it's not very good. It's better to write a small-step semantics when we have diverging loops. So, this is why we switch to small-step semantics. But, this small-step semantics is only for commands. We stay with the big-step semantics with expression because it's convenient, right? So, small-step semantics is a transition relation like this one. The general form of this relation is given a semantic state that may be defined in different ways. We move from a state S to a state S'. And then, I told you that you only need to define this step relation. Then, you can reuse the library that computes the reflexive positive conjurance rule, the star relation. So, as soon as, given this library, you only need to define this relation. Then, you can use this relation in order to model the execution of a goal program, right? So, what's the plan for today? Well, the theorem we had was only for terminating programs. So, we need a similar theorem for diverging programs. This raises the question of the following question. How can we compare the behaviors of two programs? Behavior means here termination and divergence because I also told you about going wrong behavior. Going wrong means abnormal behaviors. And, in compiler, in verified compilation, we do not want to preserve such behaviors, right? So, today we will see how to compare, in a general way, the two behaviors of programs. And, of course, now we decided to switch to a small-step semantics. So, we need to define the small-step semantics. So, first, I will answer to this question, how to compare the behavior of two programs. The answer is to use simulations that I will introduce today. And then, I will discuss what is a good semantics for, a small-step semantics for this language. Okay, so I've shown this example yesterday just to explain to you that we do not want to preserve going wrong behaviors. Here is another example because some people were talking about undefined behaviors. Indeed, in the C reference language, there is this notion of undefined behavior. Undefined means that your program can do anything. It may terminate or it may crash. You don't know. It's okay. One example of such undefined behaviors according to the C standard is an out-of-bound array access in an array, like this one. Here, I'm initializing an array X of two elements. I store in this array 12 and 24. And then, I'm storing in the third cell of the array. The first cell has an index 0. So, I'm storing a value. So, this is an out-of-bound behavior. So, the semantics of this program is that it goes wrong because of an out-of-bound array access. However, the code generated by the compiler will not... We can generate code for this program. And the generated code does not check... Will not check the out-of-bounds. And so, this program may crash or it may print... It may terminate and print an arbitrary integer depending on what is already stored in memory. So, this is another example of undefined behavior. And so, we do not want to preserve this program. And let us note that here, the source program has one behavior and the target program may have different behaviors. It may either terminate or go wrong. Right? So, now let's look at this notion of simulation between programs. So, we are... Our correctness property is a semantic preservation property. And so, when you want to compare two behaviors of a program, you use simulations. There are different kinds of simulations. The more constrained one is called big simulations. You have big simulations between two program executions when the two programs do exactly the same. Right? This means that every behavior of the source program is a possible behavior of the compiled program. And each possible behavior of the compiled program is a possible behavior of both. So, this means that you cannot distinguish between both programs if you look at their semantics. So, for instance, for our toy compiler, what does it mean? If we are proving a big simulation, it means that we have three different results. The compiled program terminates if and only if the source program terminates and reads the same final store.The compiled program diverges if and only if the source program diverges. And then the compiled program never goes wrong. Because I told you yesterday that because our language is very simple, the source program cannot go wrong. Right? So, this is big simulation. But in practice, this is too strong for compiler verification. So, there are other simulations that are forward simulation and backward simulation. Forward simulation means that we go forward from the source program to the target program. And so we have a forward simulation between a source program S to a compiled program C when every possible behavior of S is a possible behavior of C. Right? So, the theorem we had yesterday was a forward simulation because we had a hypothesis that the semantic of the source program was terminating. And then we had to prove that it was the same for the compiled program. So, it was a forward simulation for a diverging program. So, here in our example, if we want a forward simulation, we will also have to show the similar property for a diverging program. So, if the source program diverges, then the compiled program should diverge as well. Okay, but this looks insufficient because, for instance, we could be in a situation where the compiled program has more behaviors than the source program. Right? So, this simulation is interesting, but in some situations, it is not sufficient. So, this is why it is not sufficient. Because of non-determinism. So, we say that a language is deterministic if every program has only one behavior according to the semantics. Right? And, unfortunately, in C, the C language is not a deterministic language. Indeed, in C, when you evaluate expression, you can evaluate expression in different ways. And so, a source program may have different behaviors. For instance, here, let's look at this C snippet. And here, variable x is a global variable initialized to 0. Then I have a function f that increments this variable x and returns its value. And I have a function j that does the same, but decrements x and its value. Okay? So, if I want to evaluate the expression col2f plus col2b, according to the C standard, two values are possible. It's not because I wrote C f first, that f will be evaluated first. Okay? So, this is the semantics of C, such as defined in the ISOC standard. So, if I'm evaluating first f, then I will increase x by 1. So, this code will return 1. And then, when I will call f, j, 1 will become 0. But when I will evaluate this expression from left to right, the value of the expression will be 1. Okay? 1 plus 0. But I can also call j first, and then call f, in which case the result will be different. Because here x was 0, so here x will be minus 1, and then x will be 0, so the value of the expression will be minus 1. Okay? So, this language is not deterministic, because the source program may have two different behaviors. So, what do compilers do in such situations? So, the first pass is to... This is not convenient to have such non-deterministic semantics. So, compilers choose one evaluation order or compile time, and very often this is the first pass of the compiler. And this is what concept is going on. But here, this means that the compiled code has fewer behaviors than the source program. So, this means that the simulation fails, and also forward simulation fails. Okay? So, this is why we can use... In such situations, we can use backward simulation from the source, or from the compiled program to the source program. So, we have a backward simulation where every possible behavior of the compiled program is a possible behavior of s. And in this situation, c may have fewer behaviors than s. Okay? Moreover, if the target... We have another result. That is, if the target language is deterministic, then a forward simulation implies a backward simulation, and therefore a b-simulation. Okay? So, to sum up, there are three kinds of simulations. B-simulation, forward simulation, and backward simulation. B-simulation are often too strong, so we are not interested by b-simulation. So, we have forward simulation and backward simulation. And backward simulation seems to be the property we expect from the correct compiler. However, backward simulations are harder to prove. So, when we will have the choice, we will prefer having forward simulation than backward simulation. Right? Yes? So, b-simulation is an equivalence, and then forward simulation is one implication of the equivalence, and backward simulation is the other direction? Yes. Okay. Yes? Why not just, like, take an evaluation error and just, like, in the case of f plus g... Yes? ...if you do what, like, maybe some of the other compilers do? Yes. This is what compilers do. Yes, but if you want to prove this first class, you cannot use... You have to prove this class where there are fewer behaviors in the target condition. But for all the remaining classes, you don't have this problem. So, you have it only once, but you have to deal with it, and to use a backward simulation for this case. But for all the remaining cases, you... We have the choice, and so we will choose a forward simulation. Yes? What about rejecting it? What? Sorry? What about rejecting it? Because the... Do you want to reject my program? But it's... My expression should be okay according to the system. So, why should I reject it? It's a bad program. Yes, but the system doesn't say that. I want to provide a realistic program. So, according to the standard, right? So... Do you have a question yet? Yes? Yes, I just wanted to make sure I understood that last part. What you're saying is basically we have maybe this first pass, that gets us from the non-determinism to the determinism there, where you depend on that bespoke proofs, and things like that. But then everything else is like, oh, we just do whatever, and it's easy. Easy is the wrong word to ask, but... Yes, exactly. Okay. So, I wanted to show this for concepts, but maybe I can just show it now. Because... Yeah. So, here... Yeah. So, this is for concepts with many passes, but it's the same thing. So, we have a source language that is not deterministic. So, we will use forward simulation for all the remaining passes. Of course, we also have a general theorem that states that you can compose forward simulations. So... And then we will only have one backward simulation here. So, what can we do with all this? So, we compose all the forward simulations. Then we have one forward simulation. This assembly, this is the assembly language. So, this is a deterministic language. So, we know that forward simulation implies backward simulation. And once again, we can change backward simulation together. So, in the end, we have a backward simulation.Right? So, this is why the main theorem of concepts is a backward simulation. So, that's the plan. So, let me come back. Do you find that there is a bi-similarity between C-Light and the other sub-layers? Between? If you do C-Light and the other sub-layers, there is a bi-similarity. No, no. There is not. Because of... No. This language is not deterministic here. So, there are fewer behaviors here. But only from C-Light. Ah, from C-Light. Yes. So, that's the plan. So... If the target language is deterministic. Yes. Yes, the assembly is deterministic. The only language that is not deterministic is the switch language. Okay. Okay. Yes, exactly. But that's not for today. That's the reason. Yeah? It's like when... In formal verification, when you do refinements, you split things in simpler things. That's the idea. Okay. So, we will use forward and backward simulations. Forward simulations are easier to prove. And remember that I told you that we do not want to preserve going-on behavior. So, we... There are three kinds of behavior, if you remember. So, we... Termination. So, termination is a finite number of steps from an initial state to a finite state. Diverging behavior corresponds to an infinite number of steps. And there are also going-on behaviors. That is, a program starts executing until reaching a stuck state. The stuck state is a state that is not a finite state from which we cannot do anything. Right? So, these are the three kinds of behavior we have seen yesterday. And we only want to preserve safe programs that are programs that either terminate or diverge. Right? So, what we need for compiler verification is safe forward simulation or a safe backward simulation, where only termination and divergence are preserved. Okay? So, what is a safe forward simulation? It says that any behavior of the source program other than going-on is a possible behavior of the compiler. Right? And the same way, we have safe backward simulations that say that for any behavior B of the compiled code, the source program may either have behavior B or go-on. Okay? So, these are the two properties we are interested in when we want to prove the compiler. So, how to prove these properties? The technique is to use simulation diagrams that I will explain afterwards. Indeed, these behaviors are sequences of transitions, such as this one. And so, to prove a forward simulation from a source program as to a compiled code B, what do we need to do? We need to show that every transition in the source program, we take one transition, and we need to show that this transition is simulated by some transitions in the compiled program. That's not all. We also need to preserve an invariant between the semantic states. So, this was the question we raised before. Of course, we need to, for instance, to match names and so on, and all this is included in the invariant. Okay? Backward simulation is similar. The only difference is that it simulates transition of the compiled program by transition of the source program. Right? Okay, so let's look at such diagram for forward simulation. So, the simplest diagram is called a log-step simulation, where every transition in the source program is simulated by exactly one transition. We have a one-to-one correspondence. Each time I do a step in the source program, the compiled program does one step. Right? So, what I need to prove is what is written in red. Let's suppose I'm doing a step in the source program from state S1 to state S2, and so S1 and S2 are semantic states. Right? And then, I need to prove that this step is simulated by a step in the target program. In the target program, I need to start from a state that matches with my initial set S1. Right? It's not exactly the same state because, for instance, here I may have variables and here I may have registers, so in the invariant I need to mark variables to register and things like that. Right? This is why it's not the same state. We are more generally an invariant between the states of the source language and the states of the target language. So, given this state S1, given the step from S1 to S2, we need to show that what is in red. So, I can do a step. There exists a state C2 in the compiled program, such that I can do a step from C1 to C2, such that I have the same invariant, the same relation, the same matching between S2 and C2. Okay? So, we need to further show that initial states are related by this invariant, and then we also need to show that final states are related. Meaning that I have, once again, this invariant. I know that S is a final state and I must show that C is a final state as well. Yes? This is for backward simulation? No, this is for forward simulation. Okay? So, I told you that I will need to have both simulation forward and backward, and here, because it is simpler to understand, I chose to show you a detail only forward simulation. But from the diagram point of view, it is the same. Okay? Yes? So, I was wondering, in the compiled program, let's say you have this transition from one paper to another, it might take two steps. So, this diagram does not work. I need another diagram. No, it's here. It's the first diagram. Right? Okay. So, this is the proof I have to do, this log-steps simulation. And, yes, once I have proven such a simulation, then this simulation, the diagrams can be chained together. Right? Because here, one diagram is only about one step of the execution, and I need to have as many simulations as I have steps in my source program. Okay? But if I have a simulation like this first one here, I can prove that I can chain all the log-steps simulations for a terminating program. Okay? So, this theorem, I can show it once. So, each time I have to prove the correctness of a pass, I only need to prove a simulation diagram. And, likewise, if my source program makes an infinity of transitions, I can have the same result. I can chain all the simulation diagrams. So, this one is for log-steps simulation, but of course log-steps simulation is not enough. For instance, we have seen yesterday that the compilation of an assignment here resulted in several instructions in the virtual machine language. So, in that case, I cannot use a log-steps simulation. I need to have a plus simulation matching one step in the source execution to one of several steps in the target execution. Right?So, that's the same with this kind of diagram here. This is a forward simulation, and I can chain all the diagrams together. But this is not enough because my compiler may optimize some code, so it can remove some instructions. So, I may be in a situation where one step in the source program corresponds to zero steps in the target program. So, there is a third kind of simulation diagram that is a start simulation matching one step in the target program to zero, one, or other steps in the target program. Okay? So, this is the diagram we would like, and with such a diagram, if I am only interested in terminating programs, that will be fine. However, my semantics also observes diverging programs, and I am getting into trouble if I am mixing this kind of diagrams and diverging executions. I cannot have a diagram like that with diverging executions. Why? Because of something that is called a stuttering problem. Indeed, let's suppose that my source program is diverging, so I have an infinite number of transitions in my source language. It could happen that I would be in the following situation. The source program diverges, but the compiled code can terminate normally or by going wrong. And in that case, I would have to match an infinity of transitions with always the same state in the compiled code. Okay? Until now, nothing prevents us to face this situation. So, remember the initial theorem of compiled correctness, the specification. The target program must behave as prescribed by the semantics of the source program. So, given the theorem, such a situation should not be possible. It must not be possible. Right? Because here I have a source program that is diverging and a target program that is terminating. So, I should avoid these situations and never have such situations when trying to prove my compiler. Indeed, such situations correspond to incorrect optimizations of the diverging program. For instance, let's suppose that my optimizations compile an infinite loop while true skip into skip. If I want to prove that it's correct, I will have such a diagram. But this is not a correct specification. It does not respect my specification of compiler correctness. Right? So, because of diverging programs, if I want to use simulation diagram, I must avoid such situations. How can we do this? The solution is to add what is called a measure that shows that we are still making progress when executing the source program. So, two situations may happen. Either I have a plus program, a plus simulation as before where everything works well, but this is not enough because of diverging. So, I may have this situation where a step in the source execution corresponds to zero step in the target execution. But in that case, to avoid infinite stuttering, I need to have a measure computed from the semantic states of the source program, which say that if I am doing a step from S to S', this means that I am kind of making some progress in the execution. So, a measure is here a natural number that decreases. So, it's a standard technique to prove termination. If I have a natural number that is decreasing, it shows that my program, my execution will terminate. So, in other words, if the source program diverges, it must perform infinitely many non-stuttering steps so the compiled code executes infinitely many transitions. So, this is the most general simulation diagram I can use. So, I have to prove these two things, either a plus simulation or here this simulation with the measure. And so, this simulation technique is quite standard, it's well known. The difficult part in the proof is to find the right invariant and to find the measure. This is just to recall you that there is a companion code development where everything is written in code, all what I've presented before. To sum up this part, we have a correctness theorem about small-step semantics that concerns the negating and diverging programs that we want to show, we want to preserve. Now we know how to prove this theorem. The trick is to reason by using simulation diagrams and because we have diverging programs, we have strengthened this simulation diagram with an anti-stuttering measure. So, what remains to be done? We still need to equip this heap language with small-step semantics, only the step relations, and then we need to compute the proof once we have the semantics. So, let's see now what is small-step semantics for this source language. And if you remember well, we want small-step semantics because we have diverging programs. Okay, what is small-step semantics for heap? It is another relation. Remember that we use relation because it's more general than function and we want to reason by induction on this relation. So, given a command with p, I forgot to say that for the expression, we already have a big-step semantics and we keep it, right? We only change the semantics of commands because of y. So, given a command and initial state s, the small-step will transform c into c-prime and will update state s into s-prime. What does it mean here? So, here this is a kind of reduction semantics. A small-step starting from an assignment will reduce this assignment into a skip statement. And for that, as in the big-step semantics, I need to evaluate the expression using the same function. So, I need to do exactly the same that I was doing in the big-step semantics. I need to update the value of x into the state s. So, I chose here the notation that you have seen in software information. So, this is my small-step semantics. Then, what is the semantics for a sequence of two commands? I want to do a small-step semantics when I execute a sequence of c1 followed by c. And here, I just say that I start by doing a small-step in the execution of c1. I am not executing the whole subcommand as in the big-step semantics. I am only executing a small-step. Hence, here this small-step here from c1 to c2, right? And this small-step will update s1 into s2, which will be the final step here. So, here this is a transition rule. So, I will do some transitions until c1 is completely reduced. I should have written the reverse here. It is skip followed by c, right?Maybe I can change it now. Strange. Yes? Yes, you have a question? This one? So, I am doing exactly the same as in the big-step semantics. First, I need to evaluate expression A. And then, I am updating the current value of x into memory store S, right? So, how do I evaluate expression E using my big-step semantics A eval of A and S? And then, here, if you remember, the memory store is a function from variables to value. So, here, this is a notation used in the 5-UFC in the last week to say that in S, the new value of x becomes A eval of A and S, right? I am only changing the variables. It is exactly the same rule as what I was doing in the big-step semantics. Sorry, is the religious C over S? This is starting from a memory store S. I am updating the store here. All this is a new store, right? Maybe I should have used another notation, but it is the same as the one you have seen earlier. So, this is a notation I could have written. Here is my new store S', which is exactly the store where the new value of x becomes A eval of A and S. So, in store S, we change the value of x, which becomes this new value. We could, in the 5-UFC last week, it is also called update x. I don't remember the order of the parameters, but given x, update S into this thing, right? It is the same. Okay, so... Let's look at the rules. The rules for if statements. So, if I have an if command, if Bayesian, C1 and C2. And if I know that the evaluation of here is true, this is a big-step evaluation. We could also have done a small-step evaluation for expression, but it is not useful here, so we stay with the big-step evaluation. So, we know that the condition here is true, and so we reduce this if command into its z-branch. We do the same for the x-branch as well. Okay. So, similarly for the y-loops. Here, if we know that the condition of the loop is true, we reduce the loop into skip. And if the condition of the loop is true, then we unfold the loop. Okay? So, this is one way of defining a big-step semantics for C. So, now we have seen before the big-step semantics for x and y-branch. Now we have defined the small-step semantics. And we could also prove that both semantics are equivalent. So, this is the notation for my big-step semantics. I can show that for all commands for all states s and x-branch, if I have this big-step evaluation, this is equivalent to say that I have this small-step evaluation here. So, I have shown you before the step correlation. Then, I am using this reflective transitive closure. And to say that I am executing the full program here, I know that I have executed the whole program because the command here was reduced to skip. Right? So, when we use 3D semantics, this is a standard result. And by the way, this is useful to get confidence in the semantics. For instance, when I was designing the C-like semantics for concerts, this is the kind of things I have done to be sure that my semantics were, yeah, to get more confidence. Okay? So, once again, I will not detail this, but if you look at the companion development, you have all the proof of the equivalence. It is also done in software foundation in other files. Okay. So, now I have my small-step semantics. My goal is to prove a simulation. The simulation I have shown you before with the anti-stuttering measure. And here, I am facing a new problem. Because of my small-step semantics, here I am in the situation where some small-step semantics rules generate fresh commands that are now subterfs of the source program. So, the idea here is that, yeah, my semantics is describing the dynamics of my program, something dynamic, but my compiler is doing things statically, right? So, it does not, during compilation, the source part of my program never changes. But here, because of the rule for sequences, when I have this sequence, if command followed by a command, it will generate a small-step. For instance, when the condition of B is true, it will generate a small-step, which will generate this fresh command, C1 followed by C, which is not the command of my source program. And remember that my goal is to show a forward simulation. So, here, I am generating a new command in my simulation, but it will be hard to have a correspondence with this command. So, if this is something in my program, it will be difficult to handle such fresh commands with simulation diagrams, because here this fresh command does not correspond to it, right? So, because I am using simulation diagrams, it will be very impractical to reason on the execution relation, and it will be difficult to define the measure. Yes? Excuse me, can you explain which is the new fresh command? The new? The one? The one in brown? In my source program, I have this if command followed by C, right? Even on the component? This is my, here, this is a part of my source program, but according to my semantic rules, it will generate C1 followed by C. You mean the whole C plus C? Yes, yes. So, it generates fresh commands, since we make it impractical to use a simulation, because a simulation is, when proving a simulation, I always have to make a correspondence between one step and one or several steps. But here, if I am generating fresh commands, it will become very difficult. Yes? So, when you have this behaviour coming out in the semantics, how do you, I guess in real time, how do you observe it? Are you analysing the output code? How am I observing the correct and incorrect behaviours?Are you analysing the memory? So, if I want, so, how do I observe the behaviours? The solution is to have an interpreter that does exactly what the semantics is defining, right? Now, it's a simple interpreter. You can see a semantics as a way to compute all possible behaviours of the program. If your program has several behaviours, then you can compute all the programs. And if it has only one program, only one behaviour, you can compute this behaviour. Okay? So, you may observe this with an interpreter that you can use to run, you can run it on some specific program of your own. Right? Yes? I do see a correspondence. I cannot understand the problem part. This is what I see there. C1 can be very complicated. It's a series of commands. C. C1. C1 can be very complicated. But... No, no, that's not the problem. Yeah, that's not the problem. That's it. I see a correspondence between C, the C, and C1 to the if expression. Or statement. Or command. The if command. The correspondence C1 to the if. I get that the if is kind of lazy because it defers what's going to be executed, right? There is a correspondence. Okay? Can you see? It's C1 times the entire if construct. Yes. I agree with you, but it's difficult to express this correspondence in the simulation. In other words, I've shown you briefly how we can write a simulation diagram in Coq. What does it mean to prove a simulation diagram? It means that we will reason by induction on the step execution and so on. But because of this problem, I will not be able to simply reason by induction. In other words, I will not be able to reuse the induction principle generated by Coq directly. So I could write by myself a more adapted induction principle, but that's painful. Maybe I will do a mistake when writing this. So my goal is to have something simpler to do a simpler induction as I was doing it before. So that's the idea. So in other words, this whole step semantics is not adapted to the simulation diagrams I need to prove that my compiler is correct. Okay, so what is the solution? The solution we found was to change the style of semantics and to use what is called continuations. So the idea is instead of rewriting all commands, just better rewrite pairs made of a subcommand under focus and a continuation. A continuation means the remaining instructions, the remaining commands, together with their contours, their contexts. For instance, in the previous case, if I'm executing a sequence of two commands, okay, I will only execute the first one, so I will put the second one into the continuation. But I will remember that I was entering a new sequence of two instructions. So that's the idea. So in a continuation, here are my semantic states. I still have a memory store. I'm executing a command C, I'm doing a small step, and I also have a continuation K. And now we do a step which will update these three things, right? What do we have in continuations? So I mentioned here the sequence K. So here the dot means that I enter a sequence. So I have two executes. My continuation is C followed by a continuation K. So this means that C is the first command that will be executed in the continuation, and then K is a reminding continuation. But here this is for the sequence, and I also have loops in my language, so I have another kind of continuation where I remember the condition of the loop, the loop body, and then again a continuation, right? So that when I will look at this continuation, here I will know that I previously entered sequence, and here I will know that I previously entered the while loop. I also need a continuation to remember to express that nothing remains to be done. That's the end of this execution. So let's see how this changes here. So this is a rule for executing here an if statement. So once again, when we know that the condition of the loop evaluates to true, we just reduce the if into this branch, then branch, sorry. But what is changing here is the rule for sequence. So when I want to execute the sequence C1 followed by C2, I will say that I will do a step from this sequence to only C1, but I will not forget C2, I will push it into my current continuation K. So I use a dot to remember that I was in the sequence, and I put here, so the continuation is a stack, I'm pushing C2 on top of the stack, and so on. So here, in my semantics, compared to my initial small step semantics, I need to add some rules that are called focusing rules. Here I'm focusing on the left of the sequence, and I put the right of the sequence into my continuation. So I have to do this for different rules. And then I also have to leave rules for expressing that we must resume the remaining continuations. For instance, here, when I reduce my command enough, here I reduce my command into C, but there are remaining commands here. And here, I know that I have this continuation, I entered the sequence previously, so the next command will be this one. So this is here where we resume the remaining commands. Here, we do a small step from this here to the C here. So we pop this C from the continuation, and so the continuations are decreasing until reaching the end, where the continuation will be cased off. So in other words, we change the style of semantics, we added some rules, focusing rules and resuming rules, but it will make the proof much easier. Okay? Because here, in my small step semantics, I'm only generating... I never generate fresh commands. I'm only generating commands that are always the subterms of the source code. It means that I come from a sequence. Okay? Here, when I'm focusing on a sequence, I say that I'm focusing on the left part of the sequence, and I'm pushing the right part into the continuation. So dot here means... You can call it a case set, okay? It's a tag to remember that I was in the sequence before, meaning that I will execute the command in sequence. Okay? It's not the same. So here are two kinds of continuation. Either I enter a loop, or I enter a sequence. If I enter a sequence, once I will have executed the first part of the sequence, I will know that because I entered a sequence, I will execute the second part of the sequence. But in the case of the loop, it's different. For instance, here, for a language such as C, if I have a break in my loop...I will not execute the rest of the loop. Right? This is why I need to know that I entered the loop, and maybe I will not exit the loop, but I will exit from a sequence. So this represents the control flow that led to this instruction, this command. So you mean that the right value is only equal to both C and C? Yes, exactly. Yes, that's it. Okay, so now I have a small-step semantics with continuations. And here, compared to the previous semantics, so here is the semantics. I already told you about the sequences. The rule for assignment does not change. The continuation does not change. I already told you about the key statements, and we have similar rules for the evaluation of loops. So, for instance, here, when I execute a loop whose condition evaluates to true, I unfold the loop, and this is where... This one is not good. This one is not good. What did I write here? It's not the right one, because it's... So here, this should be C, and when I'm entering a loop, I'm focusing on the loop body, C, and I'm pushing the rest here, the continuation. So you can remove this one. I will correct this. I'm sure that I will update my slide tonight, so tomorrow morning you will have the correct version. So I also have the resumed rule for loops. Once I have executed fully this one, it will be reduced to skip. And if I have this continuation, then it means that I entered the loop previously, so I still need to execute the loop. And this is here where it is important to know that I entered the loop. Thank you. Okay, so now I have my small-step semantics for my source language. So once again, as I did for the virtual machine, I can define the termination of the program. I only apply computing its complexity from the closure using the same star relation we have seen yesterday. And so here, what does it mean that C is a program that is terminating? So it means that initially I'm starting with a... So there is no empty continuation, so this k-stop continuation is used to say initially this is the initial continuation and this is also the final continuation, right? So initially, when I'm executing C that is a program, I start from a k-stop continuation. And if this program terminates, this means that I will have fully reduced C into skip. I will have taken into account all the remaining commands that were put in continuation, and so I have this k-stop in the end as well. Okay? And in a similar way, we also can define the semantics of a divergent program starting from the same initial state. We just say that we have this behavior and it is a sequence of states, right? So now we can write the theorem... We can write the correctness theorem. And by the way, here we have seen two different small-step semantics for the same language. So we could also prove that both semantics compute the same are equivalent. Okay? Once again, this is done in the companion development. So the new semantics with continuation is equivalent to the small-step semantics I had before, and it's exactly the same for divergent programs. Okay? This can be left as an exercise. It's not useful for compiler correctness, but once again, if you want to get confidence in your new semantics, you can first start with proving such a simpler equivalence level between semantics. Okay, so I have the small-step semantics. I know which simulation I should have. So this is the same simulation as before. I know that I will use the most general simulation. So I have this diagram with the plus on the left and this one. So what remains to be done is just to find a measure and to find the invariant here. So with respect to the previous simulation here, I have just updated the semantic states because here in the source language, so now we have this semantics, this small-step semantics with continuation. So the semantic state is made of three things, a command, a continuation, and a memory store. So these are the semantic states. And here, if you remember what I said yesterday, we have the semantic states for the virtual machines that are also triples, but made of a command counter, a stack, that is a list of integers, and the same semantic store. Okay? So I've just instantiated the generic simulation diagram I've shown you before to the semantic states on the left of me and on the right of my virtual machine. So I'm already using this diagram. So I know that I will use it. And so what remains to be done is the difficult part. So what is this invariant? And what is the measure? Right? So I will not tell you all the details about this. So once again, you can have a look at the development. But for the measure, we need to look at the small-step semantics. Can we... So the idea is the measure. Remember, the measure is an anti-stuttering measure. Okay? So we must look at what are the situations where our program may stutter. We have stuttering when no instruction is executed in the semantics of the virtual machine. And this corresponds, for instance, to these rules. For instance here, the rules for resuming the sequence. When I'm doing a step from skip to this instruction and I only copy C from the continuation here. Okay? When I'm doing such a small step, there is nothing to do at the target level. Right? So this rule may... This is where stuttering may happen. If I'm doing this step an infinite number of times. Okay? So in the same way, when I'm focusing on the... In the sequence, when I'm focusing on the left part, I'm just changing the continuation and reducing the statement and there is no... This corresponds to no execution in the target program. Right? Yes? Yeah. For this small language, yes. Yes. So in order to define my measure, I need to look at all these situations and so this is where... This is what can cause me trouble and so I need to find a measure. So contrary to simulation diagrams and quite well-known technique here, there is no technique to find a measure. Okay? It depends on the language you are considering and so on. So you have to try several measures and try to prove them and see if it's indeed a differential measure and so on. So here, for instance, we would like...Let's find a single measure. So for instance, we have on the... In the semantic group, we have here commands. Can we just, for instance, just give as a measure the size of the command? The answer is no because here, in this rule, remember that my measure must decrease during an execution and here I have an empty execution, a skip execution, so if I'm counting the size of instructions in my... of commands, here the size would be zero, but here I'm doing a step from an empty statement to a command here, okay? So I cannot just look at these commands here on the left of my semantic papers to define the measure. And so the solution is to compute the size of all the commands that appear in my rule. This means the command here, I must count the size of the command plus the size of the remaining commands that are in the continuation. And here, with such a measure, it works, so I'm summing the size of my commands. The size, so I have, remember I have a list of commands, so it's just the size of the list, but I must add the size of here, of my command here, plus the size of the commands appearing in the continuation, right? And if I'm doing this, for any rule, for any small step rules, my measure will decrease, right? So that's the idea of the measure. I think I will stop here and we will see tomorrow for the invariant, the last thing that remains to be defined in order to prove the situation directly. Okay, that's it.